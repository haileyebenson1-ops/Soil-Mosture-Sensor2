<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Arduino Web GUI (Web Serial)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 16px; max-width: 1100px; }
    h1 { margin: 0 0 8px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    .card { border: 1px solid #e6e6e6; border-radius: 14px; padding: 12px; margin-top: 12px; }
    button { padding: 10px 12px; border: 1px solid #ccc; background: #fff; border-radius: 10px; cursor: pointer; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    label { display: inline-flex; gap: 8px; align-items: center; }
    .status { padding: 6px 10px; border-radius: 999px; border: 1px solid #ddd; }
    .ok { background: #effdf2; border-color: #b6f0c4; }
    .bad { background: #fff1f1; border-color: #ffd0d0; }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    @media (max-width: 900px) { .grid2 { grid-template-columns: 1fr; } }
    #log { height: 200px; overflow: auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
           font-size: 12px; background: #0b0b0b; color: #eaeaea; padding: 10px; border-radius: 12px; }
    canvas { width: 100%; height: 340px; border: 1px solid #eee; border-radius: 14px; }
    .pill { font-size: 12px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 999px; }
    .small { font-size: 12px; color: #666; }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
  </style>
</head>

<body>
  <h1>Arduino Web GUI</h1>
  <div class="row">
    <button id="btnConnect">Connect</button>
    <button id="btnDisconnect" disabled>Disconnect</button>
    <span id="status" class="status bad">Disconnected</span>
    <span class="pill">Expected: <b>Data1,Data2</b></span>
  </div>

  <div class="card">
    <div class="row">
      <label><input type="checkbox" id="chkSave" /> Saving Data (CSV)</label>
      <button id="btnDownload" disabled>Download CSV</button>
      <button id="btnClear" disabled>Clear Plot/Data</button>
      <span class="small">Use Chrome/Edge on desktop (HTTPS). Close Arduino Serial Monitor if open.</span>
    </div>

    <div class="row" style="margin-top:10px;">
      <button id="btnLedOn" disabled>LED ON</button>
      <button id="btnLedOff" disabled>LED OFF</button>
      <span class="small">Sends <code>L1</code> / <code>L0</code> to Arduino.</span>
    </div>
  </div>

  <div class="grid2">
    <div class="card">
      <h3 style="margin:0 0 8px;">Live Plot</h3>
      <canvas id="plot" width="1000" height="400"></canvas>
      <div class="row" style="margin-top:8px;">
        <span class="pill">Latest Data1: <b id="v1">—</b></span>
        <span class="pill">Latest Data2: <b id="v2">—</b></span>
        <span class="pill">Points: <b id="nPts">0</b></span>
      </div>
      <div class="small" style="margin-top:8px;">
        Plot auto-scales. Data1 and Data2 are both shown.
      </div>
    </div>

    <div class="card">
      <h3 style="margin:0 0 8px;">Raw Data</h3>
      <div id="log"></div>
    </div>
  </div>

  <script>
    // =========================
    // Web Serial + UI state
    // =========================
    let port = null;
    let reader = null;
    let writer = null;
    let keepReading = false;

    const btnConnect = document.getElementById("btnConnect");
    const btnDisconnect = document.getElementById("btnDisconnect");
    const btnLedOn = document.getElementById("btnLedOn");
    const btnLedOff = document.getElementById("btnLedOff");
    const btnDownload = document.getElementById("btnDownload");
    const btnClear = document.getElementById("btnClear");
    const chkSave = document.getElementById("chkSave");
    const statusEl = document.getElementById("status");
    const logEl = document.getElementById("log");

    const v1El = document.getElementById("v1");
    const v2El = document.getElementById("v2");
    const nPtsEl = document.getElementById("nPts");

    const canvas = document.getElementById("plot");
    const ctx = canvas.getContext("2d");

    function setConnectedUI(connected) {
      statusEl.textContent = connected ? "Connected" : "Disconnected";
      statusEl.classList.toggle("ok", connected);
      statusEl.classList.toggle("bad", !connected);

      btnConnect.disabled = connected;
      btnDisconnect.disabled = !connected;
      btnLedOn.disabled = !connected;
      btnLedOff.disabled = !connected;
      btnClear.disabled = !connected;
    }

    function logLine(s) {
      logEl.textContent += s + "\n";
      logEl.scrollTop = logEl.scrollHeight;
    }

    // =========================
    // Data buffers + CSV
    // =========================
    const MAX_POINTS = 300;
    const series1 = [];
    const series2 = [];

    // When "Saving Data" is checked, we append rows here:
    let csvRows = [];
    const csvHeader = "timestamp_iso,data1,data2\n";

    function resetData() {
      series1.length = 0;
      series2.length = 0;
      v1El.textContent = "—";
      v2El.textContent = "—";
      nPtsEl.textContent = "0";
      drawPlot();
      logLine("[Cleared plot/data]");
    }

    // =========================
    // Plotting (simple + fast)
    // =========================
    function niceMinMax(arr) {
      let mn = Infinity, mx = -Infinity;
      for (const v of arr) {
        if (Number.isFinite(v)) { mn = Math.min(mn, v); mx = Math.max(mx, v); }
      }
      if (!Number.isFinite(mn) || !Number.isFinite(mx)) return [0, 1];
      if (mn === mx) return [mn - 1, mx + 1];
      const pad = (mx - mn) * 0.08;
      return [mn - pad, mx + pad];
    }

    function clearCanvas() { ctx.clearRect(0, 0, canvas.width, canvas.height); }

    function drawAxes(x0, y0, w, h) {
      ctx.lineWidth = 1;
      ctx.strokeStyle = "#ddd";
      ctx.strokeRect(x0, y0, w, h);
    }

    function plotLine(values, x0, y0, w, h, yMin, yMax, strokeStyle) {
      if (values.length < 2) return;
      ctx.beginPath();
      for (let i = 0; i < values.length; i++) {
        const x = x0 + (i / (values.length - 1)) * w;
        const t = (values[i] - yMin) / (yMax - yMin);
        const y = y0 + (1 - t) * h;
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      ctx.strokeStyle = strokeStyle;
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function drawPlot() {
      clearCanvas();

      const padL = 44, padB = 34, padT = 14, padR = 14;
      const x0 = padL, y0 = padT;
      const w = canvas.width - padL - padR;
      const h = canvas.height - padT - padB;

      drawAxes(x0, y0, w, h);

      // Autoscale from both series
      const [min1, max1] = niceMinMax(series1);
      const [min2, max2] = niceMinMax(series2);
      const yMin = Math.min(min1, min2);
      const yMax = Math.max(max1, max2);

      // Y labels
      ctx.fillStyle = "#666";
      ctx.font = "11px system-ui";
      ctx.fillText(yMax.toFixed(2), 6, y0 + 10);
      ctx.fillText(yMin.toFixed(2), 6, y0 + h);

      // Two lines (Data1 + Data2)
      plotLine(series1, x0, y0, w, h, yMin, yMax, "#000"); // Data1
      plotLine(series2, x0, y0, w, h, yMin, yMax, "#444"); // Data2

      // Legend
      ctx.font = "12px system-ui";
      ctx.fillStyle = "#111";
      ctx.fillText("Data1", x0 + 20, y0 + 18);
      ctx.fillText("Data2", x0 + 20, y0 + 36);
      ctx.fillStyle = "#000"; ctx.fillRect(x0 + 6, y0 + 10, 10, 10);
      ctx.fillStyle = "#444"; ctx.fillRect(x0 + 6, y0 + 28, 10, 10);
    }

    function addPoint(d1, d2) {
      series1.push(d1);
      series2.push(d2);

      while (series1.length > MAX_POINTS) { series1.shift(); series2.shift(); }

      v1El.textContent = String(d1);
      v2El.textContent = String(d2);
      nPtsEl.textContent = String(series1.length);

      if (chkSave.checked) {
        const iso = new Date().toISOString();
        csvRows.push(`${iso},${d1},${d2}\n`);
        btnDownload.disabled = csvRows.length === 0;
      }

      drawPlot();
    }

    // =========================
    // Serial helpers
    // =========================
    async function writeLine(line) {
      if (!writer) return;
      const data = new TextEncoder().encode(line + "\n");
      await writer.write(data);
    }

    async function connect() {
      if (!("serial" in navigator)) {
        alert("Web Serial not supported. Use Chrome or Edge on desktop over HTTPS (GitHub Pages works).");
        return;
      }

      // Ask the user to select their Arduino port
      port = await navigator.serial.requestPort();
      await port.open({ baudRate: 9600 });

      // Writer for commands (LED)
      writer = port.writable.getWriter();

      keepReading = true;
      setConnectedUI(true);
      logLine("[Connected]");

      // Start reading
      readLoop().catch(err => {
        console.error(err);
        logLine("[Read error] " + err.message);
      });
    }

    async function disconnect() {
      keepReading = false;

      try { if (reader) { await reader.cancel(); reader.releaseLock(); reader = null; } } catch {}
      try { if (writer) { writer.releaseLock(); writer = null; } } catch {}
      try { if (port) { await port.close(); port = null; } } catch {}

      setConnectedUI(false);
      logLine("[Disconnected]");
    }

    async function readLoop() {
      // Decode stream into text lines
      const decoder = new TextDecoderStream();
      const closed = port.readable.pipeTo(decoder.writable);
      reader = decoder.readable.getReader();

      let buffer = "";

      while (keepReading) {
        const { value, done } = await reader.read();
        if (done) break;
        if (!value) continue;

        buffer += value;
        const lines = buffer.split("\n");
        buffer = lines.pop(); // keep incomplete line

        for (const raw of lines) {
          const line = raw.trim();
          if (!line) continue;

          logLine(line);

          // Document requires "Data1,Data2" format
          const parts = line.split(",");
          if (parts.length >= 2) {
            const d1 = Number(parts[0]);
            const d2 = Number(parts[1]);
            if (Number.isFinite(d1) && Number.isFinite(d2)) {
              addPoint(d1, d2);
            }
          }
        }
      }

      await closed.catch(() => {});
    }

    // =========================
    // CSV download
    // =========================
    function downloadCSV() {
      const content = csvHeader + csvRows.join("");
      const blob = new Blob([content], { type: "text/csv;charset=utf-8" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = "arduino_data.csv";
      document.body.appendChild(a);
      a.click();
      a.remove();

      URL.revokeObjectURL(url);
    }

    // =========================
    // Events
    // =========================
    btnConnect.addEventListener("click", connect);
    btnDisconnect.addEventListener("click", disconnect);

    btnLedOn.addEventListener("click", async () => {
      await writeLine("L1");
      logLine("[TX] L1");
    });

    btnLedOff.addEventListener("click", async () => {
      await writeLine("L0");
      logLine("[TX] L0");
    });

    btnDownload.addEventListener("click", downloadCSV);

    btnClear.addEventListener("click", () => {
      resetData();
      // also reset CSV capture (optional, but usually what you want)
      csvRows = [];
      btnDownload.disabled = true;
      logLine("[CSV buffer cleared]");
    });

    chkSave.addEventListener("change", () => {
      if (chkSave.checked) {
        csvRows = [];
        btnDownload.disabled = true;
        logLine("[Saving enabled] CSV will be captured.");
      } else {
        logLine("[Saving disabled]");
      }
    });

    // Init
    drawPlot();
    setConnectedUI(false);
  </script>
</body>
</html>
